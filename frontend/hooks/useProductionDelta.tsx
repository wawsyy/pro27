"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These files are auto-generated by genabi.mjs
// Import them after running: npm run genabi
import { ProductionDeltaAddresses } from "@/abi/ProductionDeltaAddresses";
import { ProductionDeltaABI } from "@/abi/ProductionDeltaABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type ProductionDeltaInfoType = {
  abi: typeof ProductionDeltaABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getProductionDeltaByChainId(
  chainId: number | undefined
): ProductionDeltaInfoType {
  if (!chainId) {
    return { abi: ProductionDeltaABI.abi };
  }

  const entry =
    ProductionDeltaAddresses[chainId.toString() as keyof typeof ProductionDeltaAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: ProductionDeltaABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: ProductionDeltaABI.abi,
  };
}

export const useProductionDelta = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [deltaHandle, setDeltaHandle] = useState<string | undefined>(undefined);
  const [clearDelta, setClearDelta] = useState<ClearValueType | undefined>(
    undefined
  );
  const clearDeltaRef = useRef<ClearValueType>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isCalculating, setIsCalculating] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const productionDeltaRef = useRef<ProductionDeltaInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);
  const isCalculatingRef = useRef<boolean>(isCalculating);

  const isDecrypted = deltaHandle && deltaHandle === clearDelta?.handle;

  const productionDelta = useMemo(() => {
    const c = getProductionDeltaByChainId(chainId);
    productionDeltaRef.current = c;
    if (!c.address) {
      setMessage(`ProductionDelta deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!productionDelta) {
      return undefined;
    }
    return (Boolean(productionDelta.address) && productionDelta.address !== ethers.ZeroAddress);
  }, [productionDelta]);

  const canGetDelta = useMemo(() => {
    return productionDelta.address && ethersReadonlyProvider && !isRefreshing;
  }, [productionDelta.address, ethersReadonlyProvider, isRefreshing]);

  const refreshDeltaHandle = useCallback(() => {
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !productionDeltaRef.current ||
      !productionDeltaRef.current?.chainId ||
      !productionDeltaRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setDeltaHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = productionDeltaRef.current.chainId;
    const thisAddress = productionDeltaRef.current.address;

    const contract = new ethers.Contract(
      thisAddress,
      productionDeltaRef.current.abi,
      ethersReadonlyProvider
    );

    contract
      .getDelta()
      .then((value) => {
        if (
          sameChain.current(thisChainId) &&
          thisAddress === productionDeltaRef.current?.address
        ) {
          setDeltaHandle(value);
        }
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("ProductionDelta.getDelta() call failed! error=" + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, sameChain]);

  useEffect(() => {
    refreshDeltaHandle();
  }, [refreshDeltaHandle]);

  const canDecrypt = useMemo(() => {
    return (
      productionDelta.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      deltaHandle &&
      deltaHandle !== ethers.ZeroHash &&
      deltaHandle !== clearDelta?.handle
    );
  }, [
    productionDelta.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    deltaHandle,
    clearDelta,
  ]);

  const decryptDeltaHandle = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!productionDelta.address || !instance || !ethersSigner) {
      return;
    }

    if (deltaHandle === clearDeltaRef.current?.handle) {
      return;
    }

    if (!deltaHandle) {
      setClearDelta(undefined);
      clearDeltaRef.current = undefined;
      return;
    }

    if (deltaHandle === ethers.ZeroHash) {
      setClearDelta({ handle: deltaHandle, clear: BigInt(0) });
      clearDeltaRef.current = { handle: deltaHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisAddress = productionDelta.address;
    const thisDeltaHandle = deltaHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Start decrypt");

    const run = async () => {
      const isStale = () =>
        thisAddress !== productionDeltaRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [productionDelta.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        const res = await instance.userDecrypt(
          [{ handle: thisDeltaHandle, contractAddress: thisAddress }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setClearDelta({ handle: thisDeltaHandle, clear: res[thisDeltaHandle] });
        clearDeltaRef.current = {
          handle: thisDeltaHandle,
          clear: res[thisDeltaHandle],
        };

        setMessage(
          "Delta clear value is " + clearDeltaRef.current.clear
        );
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    productionDelta.address,
    instance,
    deltaHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  const canSubmit = useMemo(() => {
    return (
      productionDelta.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [productionDelta.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  const submitProduction = useCallback(
    (value: number, isToday: boolean) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!productionDelta.address || !instance || !ethersSigner || value <= 0) {
        return;
      }

      const thisChainId = chainId;
      const thisAddress = productionDelta.address;
      const thisEthersSigner = ethersSigner;
      const contract = new ethers.Contract(
        thisAddress,
        productionDelta.abi,
        thisEthersSigner
      );

      const op = isToday ? "setTodayProduction" : "setYesterdayProduction";
      const opMsg = `${op}(${value})`;

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage(`Start ${opMsg}...`);

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== productionDeltaRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisAddress,
            thisEthersSigner.address
          );
          input.add32(value);

          const enc = await input.encrypt();

          if (isStale()) {
            setMessage(`Ignore ${opMsg}`);
            return;
          }

          setMessage(`Call ${opMsg}...`);

          const tx: ethers.TransactionResponse =
            await contract[op](enc.handles[0], enc.inputProof);

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Call ${opMsg} completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage(`Ignore ${opMsg}`);
            return;
          }

          refreshDeltaHandle();
        } catch (e: any) {
          const errorMsg = e?.message || String(e);
          if (errorMsg.includes('relayer') || errorMsg.includes('ERR_CONNECTION_CLOSED') || errorMsg.includes('Failed to fetch')) {
            setMessage(`${opMsg} Failed! Relayer service unavailable. Please try using local Hardhat node (chainId: 31337) for testing.`);
          } else {
            setMessage(`${opMsg} Failed! ${errorMsg}`);
          }
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      productionDelta.address,
      productionDelta.abi,
      instance,
      chainId,
      refreshDeltaHandle,
      sameChain,
      sameSigner,
    ]
  );

  const canReset = useMemo(() => {
    return (
      productionDelta.address &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [productionDelta.address, ethersSigner, isRefreshing, isSubmitting]);

  const resetValues = useCallback(() => {
    if (isRefreshingRef.current || isSubmittingRef.current) {
      return;
    }

    if (!productionDelta.address || !ethersSigner) {
      return;
    }

    const thisChainId = chainId;
    const thisAddress = productionDelta.address;
    const thisEthersSigner = ethersSigner;
    const contract = new ethers.Contract(
      thisAddress,
      productionDelta.abi,
      thisEthersSigner
    );

    isSubmittingRef.current = true;
    setIsSubmitting(true);
    setMessage("Start resetValues()...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== productionDeltaRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const tx = await contract.resetValues();

        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();

        setMessage(`resetValues() completed status=${receipt?.status}`);

        if (isStale()) {
          setMessage("Ignore resetValues");
          return;
        }

        // Clear the local state
        setDeltaHandle(undefined);
        setClearDelta(undefined);
        clearDeltaRef.current = undefined;
      } catch (e) {
        setMessage(`resetValues() Failed! ${e}`);
      } finally {
        isSubmittingRef.current = false;
        setIsSubmitting(false);
      }
    };

    run();
  }, [
    ethersSigner,
    productionDelta.address,
    productionDelta.abi,
    chainId,
    sameChain,
    sameSigner,
  ]);

  const canCalculate = useMemo(() => {
    return (
      productionDelta.address &&
      ethersSigner &&
      !isRefreshing &&
      !isCalculating
    );
  }, [productionDelta.address, ethersSigner, isRefreshing, isCalculating]);

  const calculateDelta = useCallback(() => {
    if (isRefreshingRef.current || isCalculatingRef.current) {
      return;
    }

    if (!productionDelta.address || !ethersSigner) {
      return;
    }

    const thisChainId = chainId;
    const thisAddress = productionDelta.address;
    const thisEthersSigner = ethersSigner;
    const contract = new ethers.Contract(
      thisAddress,
      productionDelta.abi,
      thisEthersSigner
    );

    isCalculatingRef.current = true;
    setIsCalculating(true);
    setMessage("Start calculateDelta()...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== productionDeltaRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const tx = await contract.calculateDelta();

        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();

        setMessage(`calculateDelta() completed status=${receipt?.status}`);

        if (isStale()) {
          setMessage("Ignore calculateDelta");
          return;
        }

        refreshDeltaHandle();
      } catch (e) {
        setMessage(`calculateDelta() Failed! ${e}`);
      } finally {
        isCalculatingRef.current = false;
        setIsCalculating(false);
      }
    };

    run();
  }, [
    ethersSigner,
    productionDelta.address,
    productionDelta.abi,
    chainId,
    refreshDeltaHandle,
    sameChain,
    sameSigner,
  ]);

  return {
    contractAddress: productionDelta.address,
    canDecrypt,
    canGetDelta,
    canSubmit,
    canCalculate,
    canReset,
    submitProduction,
    calculateDelta,
    resetValues,
    decryptDeltaHandle,
    refreshDeltaHandle,
    isDecrypted,
    message,
    clear: clearDelta?.clear,
    handle: deltaHandle,
    isDecrypting,
    isRefreshing,
    isSubmitting,
    isCalculating,
    isDeployed
  };
};

